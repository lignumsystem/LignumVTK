#include <LignumVTKTree.h>
namespace lignumvtk{
  TubeActorVector& CreateVTKTubeActor::operator()(TubeActorVector& v, PDMptr pdm)const
  {
    vtkNew<vtkActor> ta;
    ta->SetMapper(pdm);
    v.push_back(ta);
    return v;
  }

  TubeMapperVector& CreateVTKTubeMapper::operator()(TubeMapperVector& v, TFptr tf)const
  {
    vtkNew<vtkPolyDataMapper> tm;
    tm->SetInputConnection(tf->GetOutputPort());
    vtkPolyData* polydata = tf->GetOutput();
    tm->SetScalarRange(polydata->GetScalarRange());
    tm->ScalarVisibilityOn();
    v.push_back(tm);
    return v;
  }
    
  TubeFilterVector& CreateVTKTubeFilter::operator()(TubeFilterVector& v, PFSptr fs)const
  {
    vtkNew<vtkTubeFilter> tf;
    vtkPolyData* polydata = fs->GetOutput();
    tf->AddInputData(polydata);
    tf->SetVaryRadiusToVaryRadiusByAbsoluteScalar();
    tf->SetNumberOfSides(TUBE_NUMBER_OF_SIDES);
    tf->CappingOn();
    tf->Update();
    v.push_back(tf);
    return v;
  }

  PFSVector& CreateVTKSpline::operator()(PFSVector& v, TSData& data)const
  {
    vtkNew<vtkParametricFunctionSource> pfs;
    vtkNew<vtkParametricSpline> spline;
    vtkNew<vtkPoints> points;

    vtkIdType n = static_cast<vtkIdType>(data.vpoints.size());
    for (vtkIdType i=0; i < n; i++){
      Point p = data.vpoints[i];
      points->InsertPoint(i,p.getX(),p.getY(),p.getZ());
    }
    
    spline->SetPoints(points);
    pfs->SetParametricFunction(spline);
    pfs->SetUResolution((this->resolution) * points->GetNumberOfPoints());
    pfs->Update();
    v.push_back(pfs);
    return v;
  }

  LineActorVector& CreateVTKLineActor::operator()(LineActorVector& v, TSData& data)const
  {
    vtkNew<vtkLineSource> line_source;
    vtkNew<vtkPoints> points;
    vtkNew<vtkPolyData> polydata;
    vtkNew<vtkPolyDataMapper> mapper;
    vtkNew<vtkActor> actor;
    vtkNew<vtkNamedColors> colors;
    
    vtkIdType n = static_cast<vtkIdType>(data.vpoints.size());
    assert(n==2 && "CreateVTKLineActor: Line can have two points");
    Point p1 = data.vpoints[0];
    Point p2 = data.vpoints[1];
    cout << "P1:   " << p1 << " P2:   " << p2 << " D: " << (p1||p2) << endl;
    for (vtkIdType i=0; i<n; i++){
      Point p = data.vpoints[i];
      points->InsertPoint(i,p.getX(),p.getY(),p.getZ());
    }
    double vtkp1[3];
    double vtkp2[3];
    points->GetPoint(0,vtkp1);
    points->GetPoint(1,vtkp2);
    cout << "P1vtk: " << vtkp1[0] << " " << vtkp1[1] << " " << vtkp1[2]
	 <<" P2vtk: " << vtkp2[0] << " " << vtkp2[1] << " " << vtkp2[2] <<endl;
    line_source->SetPoint1(vtkp1);
    line_source->SetPoint2(vtkp2);
    line_source->Update();
    vtkSmartPointer<vtkPolyData> polyData = line_source->GetOutput();
    vtkSmartPointer<vtkPoints> outputPoints = polyData->GetPoints();
    vtkSmartPointer<vtkPointData> pointdata = polyData->GetPointData();
    vtkNew<vtkDoubleArray> line_width;
    int npoints = outputPoints->GetNumberOfPoints();
    line_width->SetNumberOfTuples(npoints);
    line_width->SetName(data.vname[0].c_str());
    line_width->InsertTuple1(0,data.vR[0]);
    line_width->InsertTuple1(1,data.vR[1]);
    pointdata->SetScalars(line_width);
    // colors->SetNumberOfComponents(3);
    // colors->SetNumberOfTuples(1);
    // colors->SetTuple3(0,34, 139, 34);
    // polydata->GetCellData()->SetScalars(colors);
    //polydata->GetCellData()->SetActiveScalars(data.vname[0].c_str());
    mapper->SetInputConnection(line_source->GetOutputPort());
    mapper->Update();
    actor->SetMapper(mapper);
    actor->GetProperty()->SetLineWidth(LINE_WIDTH);
    actor->GetProperty()->SetColor(colors->GetColor3d("green").GetData());
    v.push_back(actor);
    return v;
  }
    
  TSDataVector& LignumToVTK::treeToPetioleData(LignumVTKTree& t, TSDataVector& v)
  {
    v = AccumulateDown(t,v,Append,CollectPetioleData<TLSSegment,TLSBud,Kite>());
    return v;
  }
  
  TSDataVector& LignumToVTK::treeToTSData(LignumVTKTree& t, TSDataVector& v)
  {
    v = AccumulateDown(t,v,Append,CollectTSData<TLSSegment,TLSBud>());
    return v;
  }
  LineActorVector& LignumToVTK::createLineActors(TSDataVector& v,LineActorVector& lav)
  {
    lav = accumulate(v.begin(),v.end(),lav,CreateVTKLineActor());
    return lav;
  }
  
  PFSVector& LignumToVTK::vtkPointsToVtkSpline(TSDataVector& v, PFSVector& pfsv) 
  {
    pfsv=accumulate(v.begin(),v.end(),pfsv,CreateVTKSpline(resolution));
    return pfsv;
  }

  PFSVector& LignumToVTK::createTubeRadiusScalars(TSDataVector& v, PFSVector& pfsv)
  {
    //There are equal number of axes and their representation as spline segments
    assert(v.size() == pfsv.size() && "The vectors must be of equal length");
    for (unsigned int i = 0; i < v.size(); i++){
      TSData& data = v[i];
      vtkParametricFunctionSource* fs = pfsv[i];
      unsigned int npoints = fs->GetOutput()->GetNumberOfPoints();
      vtkNew<vtkDoubleArray> tube_radius;
      tube_radius->SetNumberOfTuples(npoints);
      tube_radius->SetName(v[i].vname[0].c_str());
      for (unsigned int j = 0; j < data.vR.size(); j++){
	double r =  data.vR[j];
	for (int k = 0; k < (this->resolution); k++){
	  //Copy the radius for each spline point
	  tube_radius->InsertTuple1(j*(this->resolution)+k,r);
	}
      }
      //There are Npoints*Resolution+1 spline points (i.e. NPoints*Resolution line segments)
      //Add radius for the last point
      tube_radius->InsertTuple1(data.vR.size()*(this->resolution),data.vR[data.vR.size()-1]);
      vtkPolyData* polydata = fs->GetOutput();
      polydata->GetPointData()->AddArray(tube_radius);
      polydata->GetPointData()->SetActiveScalars(v[i].vname[0].c_str());
    }
    return pfsv;
  }
   
  TubeFilterVector& LignumToVTK::createTubeFilters(PFSVector& pfsv, TubeFilterVector& v)const
  {
    v = accumulate(pfsv.begin(),pfsv.end(),v,CreateVTKTubeFilter());
    return v;
  }

  TubeMapperVector& LignumToVTK::createTubeMappers(TubeFilterVector& tfv,TubeMapperVector& v)const
  {
    v = accumulate(tfv.begin(),tfv.end(),v,CreateVTKTubeMapper());
    return v;
  }

  TubeActorVector& LignumToVTK::createTubeActors(TubeMapperVector& tmv, TubeActorVector& v)const
  {
    v = accumulate(tmv.begin(),tmv.end(),v,CreateVTKTubeActor());
    return v;
  }

  LignumToVTK& LignumToVTK::addActorsToRenderer(TubeActorVector& v)
  {
    for (unsigned int i = 0; i < v.size(); i++){
      this->renderer->AddActor(v[i]);
    }
    return *this;
  }

  LignumToVTK& LignumToVTK::setActorColor(const string& color)
  {
    vtkNew<vtkNamedColors> colors;
    vtkActorCollection* actors = this->renderer->GetActors();
    int nactors = actors->GetNumberOfItems();
    vtkColor3d rgb=colors->GetColor3d(color);
    actors->InitTraversal();
    for (int i = 0; i < nactors; i++){
      vtkActor* actor = actors->GetNextActor();
      actor->GetProperty()->SetColor(rgb.GetRed(),rgb.GetGreen(),rgb.GetBlue());
    }
    return *this;
  }

  LignumToVTK& LignumToVTK::writeVTKFile(const string& file_name)
  {
    cout << "Write file" << endl;
    cout << " Reset camera" <<endl;
    this->renderer->ResetCamera();
    cout << " GetActors" <<endl;
    vtkActorCollection* actors = this->renderer->GetActors();
    cout<< " GetNumberOfItems in actors" <<endl;
    int nactors = actors->GetNumberOfItems();
    this->mb_set->SetNumberOfBlocks(nactors);
    actors->InitTraversal();
    cout << " Set PolyData from " << nactors << " Actors as " << nactors << " MultiBlockDataSet blocks" <<endl;
    for (int i = 0; i < nactors; i++){
      vtkActor* actor = actors->GetNextActor();
      if (actor == NULL){
	cout << "NULL actor " <<endl;
      }
      vtkPolyDataMapper* mapper = dynamic_cast<vtkPolyDataMapper*>(actor->GetMapper());
      this->mb_set->SetBlock(i,mapper->GetInput());
    }
    cout << " File name: " << file_name.c_str() << endl;
    this->writer->SetFileName(file_name.c_str());
    cout << " Set writer MultiBlockDataSet input data" <<endl;
    this->writer->SetInputData(mb_set);
    cout << " Update writer" <<endl;
    this->writer->Update();
    cout << " Write data" <<endl;
    this->writer->Write();
    cout << "Write file done" <<endl;
    return *this;
  }
}				     
